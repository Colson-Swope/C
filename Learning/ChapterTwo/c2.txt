Types, Operators, and Expressions 

declarations list the variables to be used, and state their type and values 
operators specify what has to be done to them 
expressions combine variables and constants to produce new values 

declaring an object as const prevents them from being changed 

lowercase for var names 
uppercase for symbolic constants 

short names for local variables 
long names for external variables 

char - one byte 
int - integer 
float - single-precision floating point 
double - double-precision floating point 
short and long apply to numbers, int can be omitted 
short is 16 bits 
long is 32 bits 
int is either 16 or 32 bit 
short is no longer than an int 

unsigned numbers are either positive or zero 

ex. if chars are 8 bits, unsigned has values between 0 and 255, signed is -128 and 127

<limits.h> and <float.h> contain values for all of these sizes 

a long constant is written as: 12345L with the "L" at the end 
a integer too big to fit into int will also be taken 
unsigned constants are written with a u or U 
ul or UL indicates unsigned long 

floatpoint constants contian a decimal (123.4) or (1e-2) or both are double, unless suffixed 
suffixes f or F indicate a float constant 
l or L indicate a long double 

a leading 0 on an integer constant means octal, 0x or 0X means hexadecimal 
ex, 037 or 0X1F
both of these constants can follow the L and U 

character constant = 'x' - numeric value of the character in the machines character set 
ex. '0' = 48

character constants participate in numeric operation, but usually for comparing two characters 

some are represented by escape sequences like \n (new line). looks like two characters, but only represents one 

full escape sequences: 

\a - alert (bell) character 
\b - backspace 
\f - formfeed 
\n - new line 
\r - carriage return 
\t - horizontal tab 
\v - vertical tab 
\\ - backslash 
\? - question mark 
\' - single quote 
\" - double quote 
\ooo - octal number 
\xhh - hexidecimal number 

\0 the null character - value is equal to zero 

constant expression - expression that only involves constants. evaluated during compilation, may be used where a constant can occur, as in: 
#define MAXLINE 1000
char line[MAXLINE+1] 

or 

#define LEAP 1
int days [31+28+LEAP+31+30+31+30...] 

string constant - sequence of zero or more characters surrounded by double quotes 
the internal representation of a string has a \0 at the end 

strlen(s) returns the length of its character string argument s 
<string.h> 

enumeration constant - list of constant integer variables 
the first name in an enum has value 0, then 1, and so on, unless explicit values are specified. unspecified values continue from the last specified value. names in enumeration must be distinct 
enumeration is an alternate to #define, often better 

declaring a variable: int lower; 
initializing a variable: int lower = 5;
external and static variables are initialized to zero by default 
automatic variables for which there is no explicit initializer have undefined (i.e garbage) values 

the const declaration can be used with array arguments to indicate the function does not change the array 

% or modulus is the remainder then x is divided by y 
cannot be applied to floats 

relational operators have lower precedence than arithmetic operators 
&& is higher than || and lower than relational and equality operators 
! converts non-zero operand into 0, and a zero operand into 1 

assigning a longer int to a shorter one might cause a warning, but are not illegal 
because chars are just small ints, they can be used in arithmetic 

s[i] - '0' gives the numeric value of the character stored in s[i]
<ctype.h> contains portable versions of wfunctions written to convert to lowercase 

explicit type conversions can be forced in any expression with a unary operator called a cast with: (type-name) expression 
expression is converted to the named type by the conversion rules above 
the precise meaning of a cast is as if the expression were assigned to variable of the specified type which then is used in place of the whole construction 
sqrt expects a double. if n is a double, then we can use sqrt((double)n) to convert n to a double before passing it to sqrt 

double sqrt(double);
root2 = sqrt(2); coerces the integer 2 into the double value 2.0 without the need to cast 

++n or n++ can only be applied to variables 

In context where no value is wanted, just the incrementing effect, as in: 

if (c == '\n')
    nl++;
    
    
REVIEW REVIEW REVIEW!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

The bitwise AND operator & is used to mask off some set of bits 
n = n & 0177 sets zero to all but the low-order 7 bits of n 
The bitwise inclusive OR operator | turns bits on 
x = x | SET_ON; sets to one in x the bits that are set to one in SET_ON 
The bitwise exclusive OR operator ^ sets a one in each bit position where its operands have different bits, and zero where they are the same 

x & y is zero, if x is 1 and y is 2 
while x && y is 1 

x << 2 shifts the value of x left by two positions, filling vacated bits with zero, this is equivalent to multiplying by 4 

right shifting an unsigned quantity always fills vacated bits with zero 
a signed quantity will fill sign bits ("arithmetic shift") on some machines and ("logical shift") on others 

the unary operator ~ converts each 1-bit into a 0-bit and vice versa 
for example x = x & ~077 sets the last six bits of x to zero 

+= is called an assignment operator 

x *= y + 1
x = x * (y + 1) 

Conditional expressions / replacing them with if / else 

brackets combine statements into a compound block 

comma operators should be used sparingly, most suitable for constructs strongly related to each other 

the trim function removes trailing blanks, tabs, and new lines from the end of a string, using a break to exit from a loop when the rightmost non-blank, non-tab, non-newline is found 

go to statements 

